
import React, { useState } from 'react';
import { Download, FileText, Image, Mail, Share2, Printer, FileJson } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { useChatStore } from '@/store/chatStore';
import { useToast } from '@/hooks/use-toast';
import jsPDF from 'jspdf';

interface ExportOptions {
  format: 'txt' | 'json' | 'markdown' | 'pdf';
  includeTimestamps: boolean;
  includeMetadata: boolean;
  includeBranding: boolean;
  pageBreaks: boolean;
  selectedMessages?: string[];
}

export const EnhancedConversationExport: React.FC = () => {
  const { messages, getCurrentSession } = useChatStore();
  const { toast } = useToast();
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    format: 'pdf',
    includeTimestamps: true,
    includeMetadata: true,
    includeBranding: true,
    pageBreaks: true
  });
  const [isExporting, setIsExporting] = useState(false);

  const generatePDF = () => {
    const pdf = new jsPDF();
    const session = getCurrentSession();
    let yPosition = 20;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const lineHeight = 6;

    // Helper function to add new page
    const addNewPage = () => {
      pdf.addPage();
      yPosition = 20;
    };

    // Helper function to check if we need a new page
    const checkPageBreak = (height: number) => {
      if (yPosition + height > pageHeight - margin) {
        addNewPage();
      }
    };

    // Title
    pdf.setFontSize(20);
    pdf.setFont(undefined, 'bold');
    pdf.text(session?.title || 'Chat Conversation', margin, yPosition);
    yPosition += 15;

    // Metadata
    if (exportOptions.includeMetadata) {
      pdf.setFontSize(10);
      pdf.setFont(undefined, 'normal');
      pdf.text(`Exported: ${new Date().toLocaleString()}`, margin, yPosition);
      yPosition += lineHeight;
      pdf.text(`Messages: ${messages.length}`, margin, yPosition);
      yPosition += lineHeight;
      pdf.text(`Model: Nexus AI`, margin, yPosition);
      yPosition += 15;
    }

    // Messages
    messages.forEach((msg, index) => {
      const isUser = msg.sender === 'user';
      const sender = isUser ? 'You' : 'Nexus AI';
      
      // Check for page break
      checkPageBreak(30);
      
      // Sender header
      pdf.setFontSize(12);
      pdf.setFont(undefined, 'bold');
      pdf.text(`${sender}${exportOptions.includeTimestamps ? ` - ${new Date(msg.timestamp).toLocaleString()}` : ''}`, margin, yPosition);
      yPosition += 10;
      
      // Message content
      pdf.setFontSize(10);
      pdf.setFont(undefined, 'normal');
      
      // Split text to fit page width
      const maxWidth = pdf.internal.pageSize.width - (margin * 2);
      const textLines = pdf.splitTextToSize(msg.text, maxWidth);
      
      textLines.forEach((line: string) => {
        checkPageBreak(lineHeight);
        pdf.text(line, margin, yPosition);
        yPosition += lineHeight;
      });
      
      yPosition += 10; // Space between messages
      
      // Page break between messages if enabled
      if (exportOptions.pageBreaks && index < messages.length - 1) {
        checkPageBreak(50);
      }
    });

    // Branding footer
    if (exportOptions.includeBranding) {
      const finalPage = pdf.internal.getCurrentPageInfo().pageNumber;
      for (let i = 1; i <= finalPage; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setFont(undefined, 'italic');
        pdf.text('Generated by Nexus AI Chat', margin, pageHeight - 10);
      }
    }

    return pdf;
  };

  const formatConversation = (format: string) => {
    const session = getCurrentSession();
    const timestamp = new Date().toISOString();
    
    switch (format) {
      case 'txt':
        let txtContent = `NEXUS AI CONVERSATION EXPORT\n${'='.repeat(50)}\n\n`;
        if (exportOptions.includeMetadata) {
          txtContent += `Session: ${session?.title || 'Chat Session'}\n`;
          txtContent += `Exported: ${new Date().toLocaleString()}\n`;
          txtContent += `Messages: ${messages.length}\n\n`;
          txtContent += `${'='.repeat(50)}\n\n`;
        }
        
        txtContent += messages.map(msg => {
          let line = `${msg.sender === 'user' ? 'YOU' : 'NEXUS AI'}: ${msg.text}`;
          if (exportOptions.includeTimestamps) {
            line += `\n[${new Date(msg.timestamp).toLocaleString()}]`;
          }
          return line;
        }).join('\n\n' + '-'.repeat(30) + '\n\n');
        
        if (exportOptions.includeBranding) {
          txtContent += `\n\n${'='.repeat(50)}\nGenerated by Nexus AI Chat\n`;
        }
        return txtContent;
        
      case 'markdown':
        let markdown = `# ${session?.title || 'Nexus AI Chat Session'}\n\n`;
        if (exportOptions.includeMetadata) {
          markdown += `**Exported:** ${new Date().toLocaleString()}  \n`;
          markdown += `**Messages:** ${messages.length}  \n`;
          markdown += `**Model:** Nexus AI  \n\n`;
        }
        markdown += '---\n\n';
        
        messages.forEach((msg, index) => {
          markdown += `## ${msg.sender === 'user' ? 'ðŸ‘¤ You' : 'ðŸ¤– Nexus AI'}\n\n`;
          if (exportOptions.includeTimestamps) {
            markdown += `*${new Date(msg.timestamp).toLocaleString()}*\n\n`;
          }
          markdown += `${msg.text}\n\n`;
          if (exportOptions.pageBreaks && index < messages.length - 1) {
            markdown += '---\n\n';
          }
        });
        
        if (exportOptions.includeBranding) {
          markdown += '\n---\n\n*Generated by Nexus AI Chat*\n';
        }
        return markdown;
        
      case 'json':
        return JSON.stringify({
          session: {
            title: session?.title || 'Chat Session',
            exportedAt: timestamp,
            messageCount: messages.length,
            model: 'Nexus AI'
          },
          exportOptions,
          messages: messages.map(msg => ({
            id: msg.id,
            sender: msg.sender,
            text: msg.text,
            timestamp: exportOptions.includeTimestamps ? msg.timestamp : undefined,
            ...(exportOptions.includeMetadata && {
              attachments: msg.attachments?.length || 0
            })
          })),
          ...(exportOptions.includeBranding && {
            generator: 'Nexus AI Chat',
            version: '2.0'
          })
        }, null, 2);
        
      default:
        return '';
    }
  };

  const downloadFile = (content: string, filename: string, mimeType: string = 'text/plain') => {
    const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleExport = async () => {
    if (messages.length === 0) {
      toast({
        title: "No messages to export",
        description: "Start a conversation to export your chat.",
        variant: "destructive"
      });
      return;
    }

    setIsExporting(true);
    
    try {
      const session = getCurrentSession();
      const baseFilename = `nexus-ai-chat-${session?.title?.toLowerCase().replace(/\s+/g, '-') || 'session'}-${new Date().toISOString().split('T')[0]}`;
      
      if (exportOptions.format === 'pdf') {
        const pdf = generatePDF();
        pdf.save(`${baseFilename}.pdf`);
      } else {
        const content = formatConversation(exportOptions.format);
        const mimeTypes = {
          txt: 'text/plain',
          markdown: 'text/markdown',
          json: 'application/json'
        };
        
        downloadFile(
          content, 
          `${baseFilename}.${exportOptions.format}`,
          mimeTypes[exportOptions.format as keyof typeof mimeTypes]
        );
      }
      
      toast({
        title: "Export successful",
        description: `Chat exported as ${exportOptions.format.toUpperCase()}`,
      });
    } catch (error) {
      console.error('Export error:', error);
      toast({
        title: "Export failed",
        description: "There was an error exporting your conversation.",
        variant: "destructive"
      });
    } finally {
      setIsExporting(false);
    }
  };

  const shareConversation = async () => {
    if (navigator.share && messages.length > 0) {
      try {
        const content = formatConversation('txt');
        await navigator.share({
          title: getCurrentSession()?.title || 'Nexus AI Chat Session',
          text: content.slice(0, 200) + (content.length > 200 ? '...' : ''),
        });
        
        toast({
          title: "Shared successfully",
          description: "Conversation shared via system share.",
        });
      } catch (error) {
        console.error('Share error:', error);
      }
    } else {
      const content = formatConversation('txt');
      await navigator.clipboard.writeText(content);
      toast({
        title: "Copied to clipboard",
        description: "Conversation copied to your clipboard.",
      });
    }
  };

  const formatIcons = {
    txt: FileText,
    markdown: FileText,
    json: FileJson,
    pdf: Printer
  };

  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="ghost" size="sm" className="text-white/70 hover:text-white hover:bg-white/10">
          <Download className="h-4 w-4 mr-2" />
          Export
        </Button>
      </DialogTrigger>
      <DialogContent className="bg-black/90 backdrop-blur-xl border-white/20 text-white max-w-md">
        <DialogHeader>
          <DialogTitle className="text-white flex items-center">
            <Download className="w-5 h-5 mr-2 text-purple-400" />
            Export Conversation
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-6">
          {/* Export Format */}
          <div className="space-y-3">
            <label className="text-sm font-medium text-white/90">Export Format</label>
            <div className="grid grid-cols-2 gap-2">
              {[
                { value: 'pdf', label: 'PDF', desc: 'Professional document' },
                { value: 'txt', label: 'Text', desc: 'Plain text format' },
                { value: 'markdown', label: 'Markdown', desc: 'Formatted markdown' },
                { value: 'json', label: 'JSON', desc: 'Structured data' }
              ].map(({ value, label, desc }) => {
                const IconComponent = formatIcons[value as keyof typeof formatIcons];
                return (
                  <Button
                    key={value}
                    variant={exportOptions.format === value ? "default" : "ghost"}
                    size="sm"
                    onClick={() => setExportOptions(prev => ({ ...prev, format: value as any }))}
                    className={`flex flex-col h-auto p-3 ${
                      exportOptions.format === value 
                        ? "bg-purple-500 hover:bg-purple-600" 
                        : "text-white/70 hover:text-white hover:bg-white/10"
                    }`}
                  >
                    <IconComponent className="h-4 w-4 mb-1" />
                    <span className="text-xs font-medium">{label}</span>
                    <span className="text-xs opacity-60">{desc}</span>
                  </Button>
                );
              })}
            </div>
          </div>

          {/* Export Options */}
          <div className="space-y-3">
            <label className="text-sm font-medium text-white/90">Options</label>
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <span className="text-sm text-white/90">Include timestamps</span>
                <Switch
                  checked={exportOptions.includeTimestamps}
                  onCheckedChange={(checked) => setExportOptions(prev => ({ 
                    ...prev, 
                    includeTimestamps: checked 
                  }))}
                />
              </div>
              
              <div className="flex items-center justify-between">
                <span className="text-sm text-white/90">Include metadata</span>
                <Switch
                  checked={exportOptions.includeMetadata}
                  onCheckedChange={(checked) => setExportOptions(prev => ({ 
                    ...prev, 
                    includeMetadata: checked 
                  }))}
                />
              </div>

              <div className="flex items-center justify-between">
                <span className="text-sm text-white/90">Include branding</span>
                <Switch
                  checked={exportOptions.includeBranding}
                  onCheckedChange={(checked) => setExportOptions(prev => ({ 
                    ...prev, 
                    includeBranding: checked 
                  }))}
                />
              </div>

              {exportOptions.format === 'pdf' && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-white/90">Page breaks</span>
                  <Switch
                    checked={exportOptions.pageBreaks}
                    onCheckedChange={(checked) => setExportOptions(prev => ({ 
                      ...prev, 
                      pageBreaks: checked 
                    }))}
                  />
                </div>
              )}
            </div>
          </div>

          {/* Export Stats */}
          <div className="flex gap-2 flex-wrap">
            <Badge variant="secondary" className="bg-blue-500/20 text-blue-300">
              {messages.length} messages
            </Badge>
            <Badge variant="secondary" className="bg-green-500/20 text-green-300">
              {messages.filter(m => m.sender === 'user').length} from you
            </Badge>
            <Badge variant="secondary" className="bg-purple-500/20 text-purple-300">
              {messages.filter(m => m.sender === 'bot').length} from AI
            </Badge>
          </div>

          {/* Actions */}
          <div className="flex gap-3">
            <Button
              onClick={handleExport}
              disabled={isExporting || messages.length === 0}
              className="flex-1 bg-gradient-to-r from-purple-500 to-blue-500 hover:from-purple-600 hover:to-blue-600"
            >
              <Download className="h-4 w-4 mr-2" />
              {isExporting ? 'Exporting...' : 'Export'}
            </Button>
            
            <Button
              variant="ghost"
              onClick={shareConversation}
              disabled={messages.length === 0}
              className="text-white/70 hover:text-white hover:bg-white/10"
            >
              <Share2 className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};
